import db from '../database.js';
import { getAdminKeyboard, getOrdersKeyboard, getOrderActionsKeyboard, getOrderStatusKeyboard } from '../keyboards/admin.js';
import { getMainKeyboard } from '../keyboards/main.js';
import config from '../config.js';
import { isAdmin, getOrderStatusText } from '../utils/helpers.js';

export async function showAdminPanel(ctx) {
    if (!isAdmin(ctx.from.id)) {
        await ctx.reply('‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞');
        return;
    }

    await ctx.reply('üëë *–ê–¥–º–∏–Ω –ø–∞–Ω–µ–ª—å*', {
        parse_mode: 'Markdown',
        reply_markup: getAdminKeyboard()
    });
}

export async function showAdminStats(ctx) {
    const stats = db.getOrderStats();
    
    let message = 'üìä *–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –º–∞–≥–∞–∑–∏–Ω–∞:*\n\n';
    
    let totalOrders = 0;
    let totalRevenue = 0;
    
    stats.forEach(stat => {
        totalOrders += stat.status_count;
        if (stat.status === config.ORDER_STATUSES.COMPLETED) {
            totalRevenue += stat.total_revenue || 0;
        }
        message += `üì¶ ${stat.status}: ${stat.status_count} –∑–∞–∫–∞–∑–æ–≤\n`;
    });
    
    message += `\nüíµ –û–±—â–∞—è –≤—ã—Ä—É—á–∫–∞: ${totalRevenue} —Ä—É–±.\n`;
    message += `üìà –°—Ä–µ–¥–Ω–∏–π —á–µ–∫: ${totalRevenue > 0 ? (totalRevenue / totalOrders).toFixed(2) : 0} —Ä—É–±.\n`;
    message += `üë• –í—Å–µ–≥–æ –∑–∞–∫–∞–∑–æ–≤: ${totalOrders}`;

    await ctx.reply(message, { parse_mode: 'Markdown' });
}

export async function showAllOrders(ctx) {
    if (!isAdmin(ctx.from.id)) {
        await ctx.reply('‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞');
        return;
    }
    const orders = db.getAllOrders();
    
    if (orders.length === 0) {
        await ctx.reply('üì¶ –ù–µ—Ç –∑–∞–∫–∞–∑–æ–≤');
    }

    for (const order of orders.slice(0, 10)) {
        const orderDetails = db.getOrderDetails(order.id);
        
        let message = `üì¶ *–ó–∞–∫–∞–∑ #${order.id}*\n`;
        message += `üë§ –ö–ª–∏–µ–Ω—Ç: ${order.first_name} (@${order.username || '–Ω–µ—Ç'})\n`;
        message += `üìû –¢–µ–ª–µ—Ñ–æ–Ω: ${order.phone || '–Ω–µ —É–∫–∞–∑–∞–Ω'}\n`;
        message += `üíµ –°—É–º–º–∞: ${order.total_amount} —Ä—É–±.\n`;
        message += `üìÖ –î–∞—Ç–∞: ${new Date(order.created_at).toLocaleDateString()}\n`;
        message += `üìä –°—Ç–∞—Ç—É—Å: ${getOrderStatusText(order.status)}\n`;
        
        if (order.user_comment) {
            message += `üí¨ –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫–ª–∏–µ–Ω—Ç–∞: ${order.user_comment}\n`;
        }
        
        if (order.admin_comment) {
            message += `üëë –í–∞—à –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π: ${order.admin_comment}\n`;
        }
        
        message += '\n*–¢–æ–≤–∞—Ä—ã:*\n';

        orderDetails.forEach((item, index) => {
            message += `${index + 1}. ${item.name} - ${item.quantity} —à—Ç. x ${item.price} —Ä—É–±.\n`;
        });
        console.log(order.id);  
        await ctx.reply(message, {
            parse_mode: 'Markdown',
            reply_markup: getOrderStatusKeyboard(order.id)
        });  
    }
}

export async function showOrdersByStatus(ctx) {
    if (!isAdmin(ctx.from.id)) {
        await ctx.reply('‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞');
        return;
    }
    const status = ctx.match?.[1] || ctx.session.filterStatus;
    if (!status) {
        await ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ —Å—Ç–∞—Ç—É—Å –∑–∞–∫–∞–∑–æ–≤:', {
            reply_markup: getOrderStatusKeyboard(0)
        });
        return;
    }
    const orders = db.getOrdersByStatus(status);
    if (orders.length === 0) {
        await ctx.reply('üì¶ –ù–µ—Ç –∑–∞–∫–∞–∑–æ–≤ —Å —Ç–∞–∫–∏–º —Å—Ç–∞—Ç—É—Å–æ–º');
        return;
    }
    for (const order of orders.slice(0, 10)) {
        const orderDetails = db.getOrderDetails(order.id);
        let message = `üì¶ *–ó–∞–∫–∞–∑ #${order.id}*\n`;
        message += `üë§ –ö–ª–∏–µ–Ω—Ç: ${order.first_name} (@${order.username || '–Ω–µ—Ç'})\n`;
        message += `üìû –¢–µ–ª–µ—Ñ–æ–Ω: ${order.phone || '–Ω–µ —É–∫–∞–∑–∞–Ω'}\n`;
        message += `üíµ –°—É–º–º–∞: ${order.total_amount} —Ä—É–±.\n`;
        message += `üìÖ –î–∞—Ç–∞: ${new Date(order.created_at).toLocaleDateString()}\n`;
        message += `üìä –°—Ç–∞—Ç—É—Å: ${getOrderStatusText(order.status)}\n`;
        message += '\n*–¢–æ–≤–∞—Ä—ã:*\n';
        orderDetails.forEach((item, index) => {
            message += `${index + 1}. ${item.name} - ${item.quantity} —à—Ç. x ${item.price} —Ä—É–±.\n`;
        });
        await ctx.reply(message, { parse_mode: 'Markdown' });
    }
}

export async function handleOrderStatusChange(ctx) {
    const [_, orderId, status] = ctx.callbackQuery.data.split(':');
    
    ctx.session.editingOrder = { 
        orderId: parseInt(orderId), 
        status: getStatusFromKey(status) 
    };
    
    await ctx.reply(`–í–≤–µ–¥–∏—Ç–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –¥–ª—è —Å—Ç–∞—Ç—É—Å–∞ "${getStatusFromKey(status)}":`);
    await ctx.conversation.enter('updateOrderStatus');
}

function getStatusFromKey(key) {
    const statusMap = {
        'created': config.ORDER_STATUSES.CREATED,
        'accepted': config.ORDER_STATUSES.ACCEPTED,
        'completed': config.ORDER_STATUSES.COMPLETED,
        'rejected': config.ORDER_STATUSES.REJECTED
    };
    return statusMap[key] || key;
}

export async function handleAddProduct(ctx) {
    if (!isAdmin(ctx.from.id)) {
        await ctx.reply('‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞');
        return;
    }

    await ctx.reply('–í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –Ω–æ–≤–æ–≥–æ —Ç–æ–≤–∞—Ä–∞:');
    await ctx.conversation.enter('addProduct');
}

export async function handleAddProductCategory(ctx) {
    if (!isAdmin(ctx.from.id)) {
        await ctx.reply('‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞');
        return;
    }
    console.log('handleAddProductCategory');
    await ctx.reply('–í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –Ω–æ–≤–æ–≥–æ —Ç–æ–≤–∞—Ä–∞:');
    await ctx.conversation.enter('addProductCategory');
}

export async function showAdminCategories(ctx) {
    if (!isAdmin(ctx.from.id)) {
        await ctx.reply('‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞');
        return;
    }
    const categories = db.getProductCategories();
    if (!categories || categories.length === 0) {
        await ctx.reply('üòî –ù–µ—Ç –∫–∞—Ç–µ–≥–æ—Ä–∏–π');
        return;
    }
    let message = 'üìÇ –ö–∞—Ç–µ–≥–æ—Ä–∏–∏:\n\n';
    for (const c of categories) {
        message += `‚Ä¢ ${c.name} (ID: ${c.id})\n`;
    }
    await ctx.reply(message);
}

export async function handleInlineEditCategory(ctx) {
    if (!isAdmin(ctx.from.id)) {
        await ctx.answerCallbackQuery('‚ùå –ù–µ—Ç –ø—Ä–∞–≤');
        return;
    }
    const categoryId = parseInt(ctx.callbackQuery.data.split(':')[1]);
    ctx.session.editingCategoryId = categoryId;
    await ctx.answerCallbackQuery('‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏');
    await ctx.conversation.enter('editCategory');
}

export async function handleInlineDeleteCategory(ctx) {
    if (!isAdmin(ctx.from.id)) {
        await ctx.answerCallbackQuery('‚ùå –ù–µ—Ç –ø—Ä–∞–≤');
        return;
    }
    const categoryId = parseInt(ctx.callbackQuery.data.split(':')[1]);
    try {
        const res = db.deleteProductCategory(categoryId);
        if (res > 0) {
            await ctx.answerCallbackQuery('‚úÖ –ö–∞—Ç–µ–≥–æ—Ä–∏—è —É–¥–∞–ª–µ–Ω–∞');
            await ctx.deleteMessage().catch(() => {});
        } else {
            await ctx.answerCallbackQuery('‚ùå –ö–∞—Ç–µ–≥–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞');
        }
    } catch (e) {
        console.error('Error deleting category:', e);
        await ctx.answerCallbackQuery('‚ùå –û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è');
    }
}

export async function handleInlineDeleteProduct(ctx) {
    if (!isAdmin(ctx.from.id)) {
        await ctx.answerCallbackQuery('‚ùå –ù–µ—Ç –ø—Ä–∞–≤');
        return;
    }
    const productId = parseInt(ctx.callbackQuery.data.split(':')[1]);
    try {
        const result = db.deleteProduct(productId);
        if (result > 0) {
            await ctx.answerCallbackQuery('‚úÖ –¢–æ–≤–∞—Ä —É–¥–∞–ª–µ–Ω');
            await ctx.deleteMessage();
        } else {
            await ctx.answerCallbackQuery('‚ùå –¢–æ–≤–∞—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω');
        }
    } catch (error) {
        console.error('Error inline deleting product:', error);
        await ctx.answerCallbackQuery('‚ùå –û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è');
    }
}

export async function handleInlineEditProduct(ctx) {
    if (!isAdmin(ctx.from.id)) {
        await ctx.answerCallbackQuery('‚ùå –ù–µ—Ç –ø—Ä–∞–≤');
        return;
    }
    const productId = parseInt(ctx.callbackQuery.data.split(':')[1]);
    console.log('handleInlineEditProduct', productId);
    // Persist product id into both ctx.session and conversation.session for reliability
    ctx.session.editingProductId = productId;
    await ctx.answerCallbackQuery('‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞');
    await ctx.conversation.enter('editProduct');
}